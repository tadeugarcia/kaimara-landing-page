"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.upsertPriceListPricesStep = exports.upsertPriceListPricesStepId = void 0;
const modules_sdk_1 = require("@medusajs/modules-sdk");
const utils_1 = require("@medusajs/utils");
const workflows_sdk_1 = require("@medusajs/workflows-sdk");
exports.upsertPriceListPricesStepId = "upsert-price-list-prices";
exports.upsertPriceListPricesStep = (0, workflows_sdk_1.createStep)(exports.upsertPriceListPricesStepId, async (stepInput, { container }) => {
    const { data, variant_price_map: variantPriceSetMap } = stepInput;
    const priceListPricesToUpdate = [];
    const priceListPricesToAdd = [];
    const pricingModule = container.resolve(modules_sdk_1.ModuleRegistrationName.PRICING);
    for (const upsertPriceListPricesData of data) {
        const { prices = [], id } = upsertPriceListPricesData;
        const pricesToAdd = [];
        const pricesToUpdate = [];
        for (const price of prices) {
            const priceSetId = variantPriceSetMap[price.variant_id];
            if (isPriceUpdate(price)) {
                pricesToUpdate.push({ ...price, price_set_id: priceSetId });
            }
            else {
                pricesToAdd.push({ ...price, price_set_id: priceSetId });
            }
        }
        if (pricesToUpdate.length) {
            priceListPricesToUpdate.push({
                price_list_id: id,
                prices: pricesToUpdate,
            });
        }
        if (pricesToAdd.length) {
            priceListPricesToAdd.push({
                price_list_id: id,
                prices: pricesToAdd,
            });
        }
    }
    const updatedPriceSetMoneyAmounts = await pricingModule.listPriceSetMoneyAmounts({
        id: priceListPricesToUpdate
            .map((priceListData) => priceListData.prices.map((price) => price.id))
            .filter(Boolean)
            .flat(1),
    }, { relations: ["price_list"] });
    const priceListPsmaMap = new Map();
    const dataBeforePriceUpdate = [];
    for (const priceSetMoneyAmount of updatedPriceSetMoneyAmounts) {
        const priceListId = priceSetMoneyAmount.price_list.id;
        const psmas = priceListPsmaMap.get(priceListId) || [];
        priceListPsmaMap.set(priceListId, psmas);
    }
    for (const [priceListId, psmas] of Object.entries(priceListPsmaMap)) {
        dataBeforePriceUpdate.push({
            price_list_id: priceListId,
            prices: (0, utils_1.buildPriceSetPricesForModule)(psmas),
        });
    }
    // TODO: `addPriceListPrices` will return a list of price lists
    // This should be reworked to return prices instead, as we need to
    // do a revert incase this step fails
    const [createdPriceListPrices, _] = await (0, utils_1.promiseAll)([
        pricingModule.addPriceListPrices(priceListPricesToAdd),
        pricingModule.updatePriceListPrices(priceListPricesToUpdate),
    ]);
    return new workflows_sdk_1.StepResponse(null, {
        createdPriceListPrices,
        updatedPriceListPrices: dataBeforePriceUpdate,
    });
}, async (data, { container }) => {
    if (!data) {
        return;
    }
    const { createdPriceListPrices = [], updatedPriceListPrices = [] } = data;
    const pricingModule = container.resolve(modules_sdk_1.ModuleRegistrationName.PRICING);
    if (createdPriceListPrices.length) {
        await pricingModule.removePrices(createdPriceListPrices.map((p) => p.id));
    }
    if (updatedPriceListPrices.length) {
        await pricingModule.updatePriceListPrices(updatedPriceListPrices);
    }
});
function isPriceUpdate(data) {
    return "id" in data;
}
